#include<iostream>
#include<math.h>
#include<stdlib.h>

void mt(float *a,float *b,int row,int column)//矩阵求转置函数
{
	int i,j;  //a是转置前矩阵，b是转置后的矩阵，row为矩阵的行数， columne是矩阵的列数
	float temp;
	for(i=0;i<row;i++){
		for(j=0;j<column;j++){
			temp = *(a+i*column+j);
			*(b+j*row+i) = temp;
		}
	}
}

void subb(float *a,float *b,int n,float *c)//矩阵相减函数
{                                          //c中存放差矩阵
	int i;
	for(i=0;i<n;i++){
		*(c+i) = *(a+i) - *(b+i);
	}
}

void madd(float *a,float *b,int n,float *c)  //矩阵相加函数
{                                          //c中存放和矩阵
	int i;
	for(i=0;i<n;i++)
	{
		*(c+i) = *(a+i)+*(b+i);  //fabs是浮点数绝对值函数
	}
}

void kmul(float *a,int n,float c,float *b) //矩阵数乘函数
{
	int i;
	for(i=0;i<n;i++){
		*(b+i) = (*(a+i))*c;
	}
}

void bmul(float *a,float *b,int m,int n,int k,float *result) //矩阵相乘矩阵
{
	int i,j,l,u;
	for(i=0;i<m-1;i++){
		for(j=0;j<k-1;j++){
			u = i*k+j;
			result[u] = 0.0;
			for(l=0;l<=n-1;l++)
			{
				result[u] = result[u] + a[i*n+1];
			}
		}
	}
	return;
}

int inv(float *a,int n) //矩阵求逆函数 n是矩阵a的阶数
{
	int *is,*js,i,j,k,l,u,v;
	float d,p;

	is = new int [n];
	js = new int [n];

	for(k=0;k<n-1;k++){
		d = 0.0;
		for(i=k;i<n-1;k++){
			for(j=k;j<n-1;j++){
				l=i*n+j;
				p=fabs(a[l]);
				if(p>d){
					d = p;
					is[k] = i;
					js[k] = j;
				}
			}
		}
			if(d+1.0 ==1.0)
			{
				delete js;
				delete js;
				std::cout<<"error matrix can not inv"<<std::endl;
				return(0);
			}
			if(is[k] != k)
			{
				for(j=0;j<n-1;j++)
				{
					u = k*n + j;
					v = is[k]*n + j;
					p = a[u];
					a[u] = a[v];
					a[v] = p;
				}
			}
			if(js[k] != k)
			{
				for(i=0;i<n-1;i++){
					u=i*n +k;
					v = i*n +js[k];
					p = a[u];
					a[u]=a[v];
					a[v]=p;
				}
			}
			l = k*n + k;
			a[l] = 1.0/a[l];
			for(j=0;j<n-1;j++){
			if(j != k)
			{
				u = k*n +j;
				a[u] =a[u] * a[l];
			}
			}
			for(i=0;i<n-1;i++){
			if(i != k)
			{
				for(j=0;j<n-1;j++)
				{
					if(j != k)
					{
						u = i*n +j;
						a[u] = a[u] - a[i*n+k]*a[k*n+j];
					}
				}
			}
			}
			for(i=0;i<n-1;i++){
				if(i != k){
				   u = i*n + k;
				   a[u] = -a[u]*a[l];
				}
			}
		}

	for(k=n-1;k>=0;k--){
		if(js[k] !=k)
		{
			for(j=0;j<n-1;j++){
				u=k*n+j;
				v=js[k]*n+j;
				p=a[u];
				a[u]=a[v];
				a[v]=p;
			}
		}
		if(is[k] != k){
			for(i=0;i<n-1;i++){
				u=i*n;
				v=i*n+is[k];
				p=a[u];
				a[u]=a[v];
				a[v]=p;
			}
		}
	}
	delete is;
	delete js;
	return (1);
	}

	void main()
	{
		const int m=20,n=7,g=3;   //m,n分别为样本个数，维数，g为分组组数
		const int u = 46;       //u为待分类数据的个数
		int i,j,k;
		float x1[m][n] = {{1,        5.38    ,  2.44   ,   2.77    ,  8.53   ,  1.58   ,   0.48},
	{1  ,  1.11   ,  1.62   ,  3.05    ,  4.29   ,   0.29   ,   0.08},
	{1  ,  3.24   ,  2.04   ,  4.55    ,  8.16   ,   1.25  ,    0.42},
	{2  ,  2.44   ,  2.09   ,  36.05   ,  5.44  ,    28.72  ,   6.25}, 
	{2  ,  2.20   ,  2.32   ,  35.94   ,  5.03  ,    28.78   ,  6.36 },
	{2  ,  2.12   ,  1.90   ,  36.80  ,   5.70  ,    28.93  ,   6.18 },
	{2  ,  2.96   ,  3.27   ,  34.55  ,   5.48  ,    28.67  ,   6.61 },
	{2  ,  2.25   ,  1.80   ,  36.43  ,   5.33  ,    28.95  ,   5.83 },
	{2  ,  2.19   ,  1.87  ,   36.69  ,   5.55  ,    28.98  ,   6.23 },
	{2  ,  1.97   ,  1.22  ,   37.61  ,   5.06 ,     31.46  ,   4.25 },
	{2  ,  2.64   ,  1.41  ,   35.73  ,   5.03  ,    32.21 ,    2.54},
	{3  ,  2.17   ,  1.22  ,   32.1  ,    6.41  ,    28.93  ,   0.15},
	{3  ,  1.81   ,  1.05  ,   31.03 ,    3.89 ,     28.78  ,   1.22},
	{3  ,  1.49   ,  0.83  ,   31.06 ,    3.85 ,     29.01 ,    0.52},
	{3  ,  2.15   ,  1     ,   30.61  ,   5.47 ,     28.07  ,   0.22},
	{3  ,  0.36   ,  0.17  ,   51.05  ,   23.45  ,   28.06  ,   0.07}, 
	{3  ,  0.12   ,  0.10  ,   62.31  ,   40.91  ,   17.37  ,   0.66 },
	{3  ,  0.22   ,  0.11  ,   53.17  ,   21.88  ,   28.64  ,   0.09 },
	{3  ,  2.33   ,  1.64  ,   33.95  ,   7.66  ,    29.54  ,   0.72 },
	{3  ,  0.93   ,  0.41  ,   11.71  ,   6.49  ,    1.6 ,      4.96}};        //x1为样本
	/////////////////////////////////////////////////////////////////////////////////// 
	float x2[u][n-1]={{5.38   , 2.44  ,   2.77   ,   8.53  ,  1.58  ,  0.48},
	{1.11  ,  1.62  ,  3.05  ,  4.29  ,   0.29 ,     0.08},
	{3.24  ,  2.04  ,  4.55  ,  8.16  ,   1.25 ,     0.42},
	{3.12  ,  1.78  ,  3.47  ,  7.41  ,   0.74 ,     0.22},
	{3.22   , 1.91  ,  3.87   , 7.69  ,  0.97  ,  0.34},
	{1.91   , 1.68  ,  34.6  ,  6.03  ,  27.47  ,  4.69},
	{2.77  ,   1.84  ,   34.74  ,   5.58  ,   29.36  ,   4.41}, 
	{2.5   , 1.55  ,  37.47  ,  5.45  ,  30.71  ,  5.36},
	{2   , 1.09  ,  35.2  ,  4.59  ,  30.27   , 3.43},
	{2.62 ,   2.25  ,  35.56  ,  5.68  ,  28.96 ,   5.79},
	{3.23  ,  2.93  ,  32.86  ,  5.43  ,  27.6  ,  5.37},
	{2.44  ,   2.09  ,   36.05  ,   5.44  ,   28.72  ,   6.25 },
	{2.20  ,   2.32  ,   35.94  ,   5.03  ,   28.78  ,   6.36 },
	{2.12  ,   1.90   ,  36.80  ,   5.70  ,   28.93  ,   6.18 },
	{2.96  ,   3.27  ,   34.55  ,   5.48  ,   28.67  ,   6.61 },
	{2.25   ,  1.80   ,  36.43  ,   5.33   ,  28.95  ,   5.83 },
	{2.19   ,  1.87  ,   36.69  ,   5.55   ,  28.98  ,   6.23 },
	{1.97   ,  1.22  ,   37.61  ,   5.06  ,   31.46  ,   4.25}, 
	{2.64   , 1.41  ,  35.73  ,  5.03  ,  32.21  ,  2.54},
	{0.14  ,  0.19  ,  69.64  ,  41.52  ,  13.73  ,  0.05},
	{0.14  ,  0.16  ,  18.68  ,  16.45 ,   0.58 ,   0.31},
	{0.21  ,  0.4  ,  78.97  ,  42.36  ,  27.18  ,  0},
	{0.3   , 0.2  ,  77.93  ,  38.32   , 36.05  ,  0.64},
	{0.32  ,  0.29 ,   56.87 ,   21.26  ,  36.2  ,  0.02},
	{0.1   , 0.16 ,   50.53  ,  16.45  ,  30.38  ,  2.29},
	{0.06  ,  0.22 ,   50.48 ,   13.46  ,  31.05  ,  1.78},
	{0.19  ,  0.09  ,  35.69 ,   6.5  ,  28.34  ,  0.77},
	{0.26   , 0.24 ,   35.41 ,   6.88 ,   28.37  ,  0.66},
	{0.13  ,  0.15  ,  40.05 ,   10.43 ,   28.36 ,   1.54},
	{1.26  ,  0.39  ,  35.16  ,  7.97  ,  24.85  ,  3.99},
	{0.88  ,  0.53  ,  38.46  ,  7.76  ,  26.24  ,  5.87},
	{1.27  ,  0.57  ,  37.06  ,  7.84  ,  27.26  ,  3.8},
	{0.22  ,  0.22 ,   43.18  ,  11.88 ,   28.93  ,  2.81},
	{0.15  ,  0.13  ,  53.09  ,  15.67 ,   35.11 ,   0.08},
	{1.28  ,  0.61  ,  34.37  ,  0.39  ,  28.94 ,   1.92},
	{0.33  ,  0.6  ,  37.65  ,  6.38  ,  30.05  ,  0.97},
	{0.49 ,   0.31  ,  53.97 ,   15.4 ,   32.87  ,  3.69},
	{2.17  ,  1.22  ,  32.1  ,  6.41  ,  28.93  ,  0.15},
	{1.81  ,  1.05  ,  31.03  ,  3.89  ,  28.78  ,  1.22},
	{1.49  ,  0.83  ,  31.06  ,  3.85  ,  29.01  ,  0.52},
	{2.15  ,  1   , 30.61  ,  5.47   , 28.07  ,  0.22},
	{0.36  ,   0.17  ,   51.05   ,  23.45  ,   28.06   ,  0.07 },
	{0.12  ,   0.10  ,   62.31   ,  40.91  ,   17.37   ,  0.66 },
	{0.22  ,   0.11   ,  53.17   ,  21.88  ,   28.64   ,  0.09} ,
	{2.33  ,   1.64   ,  33.95   ,  7.66   ,  29.54   ,  0.72} ,
	{0.93  ,  0.41  ,  11.71  ,  6.49   , 1.6  ,  4.96}};    //x2为待分类数据
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	float groupnum[g] = {0.0},group[g]={0.0},matrixmean[g][n-1]={0.0},matrixmean1[g][n-1],C[m][n-1],V[n-1][m],D[n-1][n-1],E[n-1][n-1],F[g][g];
	float Q1[g][n-1],lngi[g],mat[n-1][g],Q2[g],Q3[g],Q4[g][u];
	float x3[n-1][u],yy[g][u],result[u][g],max[u],iljj[u]={0},gailu[g][u],gailu1[u][g];
	//计算样本中各组成员数
	for(i=1;i<=g;i++)
	{
		for(j=0;j<m;j++)
		{
			if(x1[j][0] == i)
				group[i-1] = group[i-1] + 1.0;   //group[]为样本中每组的成员数
		}
	}

	for(i=0;i<g;i++)
	{
		if(i == 0)
			groupnum[i] = group[i];  //groupnum[] 为组与组之间的分界点
		else
			groupnum[i] = groupnum[i-1] + group[i];
	}

	/////////////////////////////////////////////////////////////////////
	//计算样本中每组每一维的平均值matrixmean[][]////
	for(i=0;i<g;i++)
		for(k=1;k<n;k++)
		{
			if(i == 0)
				for(j=0;j<groupnum[i];j++)
					matrixmean[i][k-1] = matrixmean[i][k-1] + x1[j][k];
			else
				for(j=groupnum[i-1;j<groupnum[i];j++])
					matrixmean[i][k-1] = matrixmean[i][k-1] + x1[j][k];
			matrixmean[i][k-1] = matrixmean[i][k-1]/group[i];    //matrixmean[][]为各族每一维的平均值
		}
		/////////////////////////////////////////////////////////////////
		//计算Q1[][]    ////
		for(i=0;i<g;i++)
			for(k=1;k<n;k++)
			{
				if(i == 0)
					for(j=0;j<groupnum[i];j++)
						C[j][k-1] = x1[j][k] - matrixmean[i][k-1];
				else
					for(j=groupnum[i-1];j<groupnum[i];j++)
						C[j][k-1] = x1[j][k] - matrixmean[i][k-1];      //C[][]为样本与均值之差
			}
			mt(&C[0][0],&V[0][0],m,n-1); //V[][]为C[][]的转置
			bmul(&V[0][0],&C[0][0],n-1,m,n-1,&D[0][0]);  //D[][]为C[][]的乘方
			kmul(&D[0][0],(n-1)*(n-1),1/(float)(m-g),&E[0][0]); //E[][]为D[][]乘以1/(m-g)因子
			inv(&E[0][0],n-1);
			bmul(&matrixmean[0][0],&E[0][0],g,n-1,n-1,&Q1[0][0]);

			////////////////////////////////////////////////////////////////////
			//计算Q2[]//
			for(i=0;i<g;i++)
				lnqi[i] = log(group[i]/m);
			mt(&matrixmean[0][0],&mat[0][0],g,n-1);
			bmul(&matrixmean[0][0],&E[0][0],g,n-1,n-1,&matrixmean1[0][0]);
			bmul(&matrixmean1[0][0],&mat[0][0],g,n-1,g,&F[0][0]);
			for(i=0;i<g;i++)
				for(j=0;j<g;j++)
					Q2[i] = F[i][i];
			for(i=0;i<g;i++)
				Q2[i]=lnqi[i] - 0.5*Q2[i];

			////////////////////////////////////////////////////////////////
			//计算yy[][]//
			mt(&x2[0][0],&x3[0][0],u,n-1);
			mt(&Q2[0],&Q3[0],1,g);
			bmul(&Q1[0][0],&x3[0][0],g,n-1,u,&yy[0][0]);
			for(i=0;i<g;i++)
				for(j=0;j<u;j++)
					Q4[i][j] = Q3[i];
			madd(&yy[0][0],&Q4[0][0],g*u,&yy[0][0]);
			mt(&yy[0][0],&result[0][0],g,u);

			//计算yy[][]中各维的最大值
			for(i=0;i<u;i++)
			{
				max[i] = yy[0][i];
				for(j=0;j<g;j++)
					if(yy[j][i] > max [i])
						max[i] = yy[j][i];
			}
			////////////////////////////////////////////////////////////////////
			//计算后验概率//

			for(i=0;i<u;i++)
			{
				for(j=0;j<g;j++)
					iljj[i] += exp(yy[j][i] - max[i]);
				for(j=0;j<g;j++)
					gailu[j][i] = exp(yy[j][i] - max[i]/iljj[i]);
			}

			//忽略小概率事件//
			for(i=0;i<g;i++)
				for(j=0;j<u;j++)
					if(gailu[i][j] < 0.005)
						gailu[i][j] = 0.0;
			mt(&gailu[0][0],&gailu[0][0],g,u);


			////////////////////////////////////////////////////////////////////////
			//显示分类结果///
			for(i=0;i<u;i++)
			{
				for(j=0;j<g;j++)
					std::cout<<gailu[i][j]<<"   ";
				std::cout<<std::endl;
			}
	}